<template>
  <view class="container">
    <scroll-view scroll-y="true" class="scroll-container">
      <view class="page-content">
        <!-- Header -->
        <view class="header-section">
          <text class="header-title">今日待办</text>
          <view class="date-row">
            <image class="icon-small" src="/static/calendar-icon.png" mode="aspectFit"></image>
            <text class="date-text">{{ todayDateStr }}</text>
          </view>
        </view>

        <!-- Pending Tasks -->
        <view class="section-container">
          <view class="section-header">
            <view class="indicator-line bg-orange"></view>
            <text class="section-title">待完成</text>
            <view class="count-badge">
              <text class="count-text">{{ pendingTasks.length }}</text>
            </view>
          </view>

          <view class="task-list">
            <view class="task-item" :class="[task.animationClass || '']" v-for="(task, index) in pendingTasks" :key="task.id" @touchstart="onTaskTouchStart">
                <view class="task-content-wrapper" 
                      :class="[(!task.isDragging ? 'task-content-animating' : '')]"
                      @longpress="showTaskMenu($event, task)"
                      :style="{ transform: 'translateX(' + (task.offsetX || 0) + 'rpx)' }">
                    <view v-if="task.pinned" class="pinned-mark"></view>
                    <view class="task-content">
                        <view class="checkbox-click-area" @click.stop="toggleTask(task.id)"></view>
                        <view class="checkbox checkbox-pending"></view>
                        <view class="task-details">
                            <text class="task-name">{{ task.name }}</text>
                            <view class="task-meta">
                                <image class="icon-tiny" src="/static/clock-icon.png" mode="aspectFit"></image>
                                <text class="task-time">{{ task.time }}</text>
                            </view>
                        </view>
                    </view>
                </view>
            </view>
          </view>
        </view>

        <!-- Completed Tasks -->
        <view class="section-container">
          <view class="section-header">
            <view class="indicator-line bg-green"></view>
            <text class="section-title">已完成</text>
            <view class="count-badge">
              <text class="count-text">{{ completedTasks.length }}</text>
            </view>
          </view>

          <view class="task-list">
            <view class="task-item" :class="[task.animationClass || '']" v-for="(task, index) in completedTasks" :key="task.id" @touchstart="onTaskTouchStart">
                <view class="task-content-wrapper"
                      @longpress="showTaskMenu($event, task)"
                      :style="{ transform: 'translateX(' + (task.offsetX || 0) + 'rpx)' }">
                    <view v-if="task.pinned" class="pinned-mark"></view>
                    <view class="task-content">
                        <view class="checkbox-click-area" @click.stop="toggleTask(task.id)"></view>
                        <view class="checkbox checkbox-completed">
                            <image class="icon-check" src="/static/check-icon.png" mode="aspectFit"></image>
                        </view>
                        <view class="task-details">
                            <text class="task-name text-completed">{{ task.name }}</text>
                            <view class="task-meta">
                                <image class="icon-tiny" src="/static/clock-icon.png" mode="aspectFit"></image>
                                <text class="task-time">{{ task.time }}</text>
                            </view>
                        </view>
                    </view>
                </view>
            </view>
          </view>
        </view>
      </view>
    </scroll-view>

    <!-- Navigation -->
    <tab-bar
      current-page="index"
      @voice-click="onVoiceClick"
      @voice-longpress="onVoiceLongPress"
      @voice-touchend="onVoiceTouchEnd"
    ></tab-bar>

    <!-- Voice Modal -->
    <voice-modal :show="showVoiceModal" @close="showVoiceModal = false" @create-task="handleCreateTask"></voice-modal>

    <!-- Listening Overlay -->
    <view v-if="isListening" class="listening-overlay">
      <view class="listening-content">
        <view class="listening-icon-container">
           <image class="listening-icon" src="/static/mic-icon-white.png" mode="aspectFit"></image>
           <view class="ripple-ring"></view>
        </view>
        <text class="listening-text">{{ realTimeText || '正在听...' }}</text>
      </view>
    </view>

    <!-- Tooltip -->
    <view v-if="tooltip.visible" class="tooltip-mask" @click="hideTooltip"></view>
    <view v-if="tooltip.visible" class="tooltip-box" :style="{ top: tooltip.top + 'px', left: tooltip.left + 'px' }">
        <view class="tooltip-item" @click="togglePin">
            <text class="tooltip-text">{{ tooltip.isPinned ? '取消置顶' : '置顶' }}</text>
        </view>
        <view class="tooltip-separator"></view>
        <view class="tooltip-item" @click="deleteTask()">
            <text class="tooltip-text text-red">删除</text>
        </view>
    </view>
  </view>
</template>

<script>
import VoiceModal from '@/components/VoiceModal.nvue';
import TabBar from '@/components/TabBar.nvue';
import db from '@/utils/db.js';

// #ifdef APP-NVUE
const dom = uni.requireNativePlugin('dom');
// #endif

const WS_URL = "ws://1.tcp.cpolar.cn:22333/ws/asr";

export default {
  components: { VoiceModal, TabBar },
  data() {
    return {
      showVoiceModal: false,
      isListening: false,
      realTimeText: '',
      isConnectionPending: false,
      isSocketOpen: false,
      currentSessionId: 0,
      tasks: [],
      pendingTasks: [],
      completedTasks: [],
      pixelRatio: 2,
      windowWidth: 0,
      windowHeight: 0,
      ignoreClick: false,
      lastTouchX: 0,
      lastTouchY: 0,
      tooltip: { visible: false, top: 0, left: 0, taskId: null, isPinned: false },
      pawRecorder: null
    };
  },
  computed: {
    todayDateStr() {
      const now = new Date();
      const month = now.getMonth() + 1;
      const day = now.getDate();
      const weekDays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      return `${month}月${day}日 ${weekDays[now.getDay()]}`;
    }
  },
  methods: {
    async loadTasks() {
        const dbTasks = await db.getTasksByDate();
        this.tasks = dbTasks.map(t => ({ ...t, animationClass: '', _isAnimating: false }));
        this.pendingTasks = this.tasks.filter(task => !task.completed);
        this.completedTasks = this.tasks.filter(task => task.completed);
    },
    async toggleTask(taskId) {
      const task = this.tasks.find(t => t.id === taskId);
      if (task && !task._isAnimating) {
        task._isAnimating = true;
        task.animationClass = 'task-item-hidden';
        setTimeout(async () => {
            const oldStatus = task.completed;
            task.completed = !task.completed;
            this.pendingTasks = this.tasks.filter(t => !t.completed);
            this.completedTasks = this.tasks.filter(t => t.completed);
            this.$nextTick(() => {
                setTimeout(() => {
                   task.animationClass = '';
                   setTimeout(() => { task._isAnimating = false; }, 300);
                }, 50);
            });
            await db.toggleTaskStatus(taskId, oldStatus);
        }, 300);
      }
    },
    async deleteTask(taskId) {
        const id = taskId || this.tooltip.taskId;
        if (!id) return;
        const index = this.tasks.findIndex(t => t.id === id);
        if (index > -1) {
            this.tasks.splice(index, 1);
            await db.deleteTask(id);
        }
        this.hideTooltip();
        this.loadTasks(); 
    },
    togglePin() {
        const task = this.tasks.find(t => t.id === this.tooltip.taskId);
        if (task) {
            const oldPinned = task.pinned;
            this.$set(task, 'pinned', !oldPinned);
            this.pendingTasks = this.tasks.filter(t => !t.completed);
            this.completedTasks = this.tasks.filter(t => t.completed);
            this.hideTooltip();
            db.toggleTaskPin(task.id, oldPinned).then(() => this.loadTasks());
        } else {
            this.hideTooltip();
        }
    },
    async handleCreateTask(taskName) {
      if (!taskName) return;
      await db.addTask(taskName);
      this.loadTasks();
    },
    onVoiceClick() {
        if (this.isListening || this.isConnectionPending) return;
        this.showVoiceModal = true;
    },
    onTaskTouchStart(e) {
        if (e.changedTouches && e.changedTouches.length > 0) {
            const touch = e.changedTouches[0];
            this.lastTouchX = touch.clientX || touch.screenX;
            this.lastTouchY = touch.clientY || touch.screenY;
        }
    },
    showTaskMenu(e, task) {
        const tooltipWidth = 240 / this.pixelRatio;
        this.tooltip = {
            visible: true,
            top: this.lastTouchY - (140 / this.pixelRatio),
            left: Math.max(10, this.lastTouchX - tooltipWidth - 20),
            taskId: task.id,
            isPinned: task.pinned
        };
        this.ignoreClick = true;
        setTimeout(() => { this.ignoreClick = false; }, 500);
    },
    hideTooltip() { this.tooltip.visible = false; },

    // Voice Interaction: Native Plugin Logic
    initRecorder() {
        // 加载原生插件
        this.pawRecorder = uni.requireNativePlugin('Paw-Recorder');
        const globalEvent = uni.requireNativePlugin('globalEvent');
        
        // 监听原生插件发出的 PCM 数据帧
        globalEvent.addEventListener('onPawRecorderFrame', (e) => {
            if (this.isListening && this.isSocketOpen && e.data) {
                // 原生层传回的是 Base64，需要转为 ArrayBuffer 发送
                const arrayBuffer = uni.base64ToArrayBuffer(e.data);
                console.log(`[Native] 收到分片: ${arrayBuffer.byteLength} 字节`);
                
                this.socketTask.send({
                    data: arrayBuffer,
                    fail: (err) => console.error('[Socket] 发送失败:', err)
                });
            }
        });
    },

    async onVoiceLongPress() {
      if (this.isListening || this.isConnectionPending || this.showVoiceModal) return;
      
      // #ifdef APP-PLUS
      // 1. 首先同步检查权限状态
      if (uni.getSystemInfoSync().platform === 'android') {
          const permStatus = plus.navigator.checkPermission('RECORD');
          if (permStatus !== 'authorized') {
              // 如果没有权限，发起请求并直接返回，不展示蒙版
              // 因为权限弹窗会中断当前的触摸流程，导致 touchend 无法触发，蒙版会卡死
              plus.android.requestPermissions(['android.permission.RECORD_AUDIO'], (e) => {
                  if (e.granted.length > 0) {
                      uni.showToast({ title: '麦克风权限已开启，请再次长按', icon: 'none' });
                  } else {
                      uni.showToast({ title: '需要麦克风权限才能使用语音功能', icon: 'none' });
                  }
              }, () => {});
              return;
          }
      }
      // #endif

      this.isConnectionPending = true;
      uni.vibrateShort();
      this.isListening = true;
      this.realTimeText = '正在连接...';
      this.isSocketOpen = false;
      
      const sessionId = Date.now();
      this.currentSessionId = sessionId;

      console.log('[Native] 建立 Socket 连接:', WS_URL);
      this.socketTask = uni.connectSocket({
          url: WS_URL,
          fail: (err) => {
              console.error('[Socket] 连接失败:', err);
              this.isConnectionPending = false;
              this.isListening = false;
          }
      });

      this.socketTask.onOpen(() => {
          if (this.currentSessionId !== sessionId) return;
          console.log('[Socket] 连接已打开');
          this.isSocketOpen = true;
          this.isConnectionPending = false;
          
          if (!this.isListening) {
              this.closeSocketAsync();
              return;
          }
          
          console.log('[Native] 启动原生录音机');
          this.realTimeText = '正在听...';
          // 调用原生插件开始录音
          if (this.pawRecorder) {
              this.pawRecorder.startRecorder();
          } else {
              console.error('[Native] 插件未加载');
          }
      });

      this.socketTask.onMessage((res) => {
          if (this.currentSessionId !== sessionId) return;
          try {
              const data = JSON.parse(res.data);
              if (data.text) this.realTimeText = data.text;
          } catch (e) {}
      });

      this.socketTask.onError((err) => {
          console.error('[Socket] 错误:', err);
          this.stopNativeInteraction();
      });
      
      this.socketTask.onClose(() => {
          console.log('[Socket] 关闭');
          this.isSocketOpen = false;
      });
    },

    async onVoiceTouchEnd() {
      if (!this.isListening) return;
      console.log('[Native] 用户松手');
      this.stopNativeInteraction();
    },

    stopNativeInteraction() {
        // 停止原生录音
        if (this.pawRecorder) {
            this.pawRecorder.stopRecorder();
        }
        
        // 发送结束指令
        if (this.socketTask && this.isSocketOpen) {
            this.socketTask.send({ data: 'STOP' });
            setTimeout(() => {
                if (this.realTimeText) {
                    this.handleCreateTask(this.realTimeText);
                }
                this.closeSocketAsync();
                this.isListening = false;
                this.realTimeText = '';
                this.isConnectionPending = false;
            }, 500);
        } else {
            this.isListening = false;
            this.closeSocketAsync();
            this.isConnectionPending = false;
        }
    },

    closeSocketAsync() {
        return new Promise((resolve) => {
            if (this.socketTask) {
                try { this.socketTask.close(); } catch(e) {}
                this.socketTask = null;
                setTimeout(() => resolve(), 200);
            } else {
                resolve();
            }
        });
    }
  },
  onShow() { this.loadTasks(); },
  onLoad() {
    try {
        const res = uni.getSystemInfoSync();
        this.windowWidth = res.windowWidth;
        this.windowHeight = res.windowHeight;
        this.pixelRatio = 750 / res.windowWidth;
    } catch (e) {}
    this.initRecorder();
    uni.$on('add-task', async (t) => { if (t && t.name) { await db.addTask(t.name); this.loadTasks(); } });
  },
  onUnload() { uni.$off('add-task'); }
};
</script>

<style>
.container { flex: 1; background-color: #FAFAFA; flex-direction: column; }
.scroll-container { flex: 1; }
.page-content { padding-left: 32rpx; padding-right: 32rpx; padding-top: 48rpx; padding-bottom: 200rpx; }
.header-section { margin-bottom: 48rpx; }
.header-title { font-size: 48rpx; font-weight: bold; color: #101828; margin-bottom: 12rpx; }
.date-row { flex-direction: row; align-items: center; }
.icon-small { width: 28rpx; height: 28rpx; margin-right: 16rpx; }
.date-text { font-size: 24rpx; color: #6A7282; }
.section-container { margin-bottom: 48rpx; }
.section-header { flex-direction: row; align-items: center; margin-bottom: 20rpx; height: 40rpx; }
.indicator-line { width: 8rpx; height: 32rpx; border-radius: 4rpx; margin-right: 16rpx; }
.bg-orange { background-color: #F1795C; }
.bg-green { background-color: #6BCF7F; }
.section-title { font-size: 28rpx; font-weight: bold; color: #101828; margin-right: 24rpx; }
.count-badge { background-color: #F3F4F6; border-radius: 8rpx; padding-left: 16rpx; padding-right: 16rpx; height: 40rpx; justify-content: center; }
.count-text { font-size: 24rpx; color: #364153; }
.task-list { flex-direction: column; }
.task-item { background-color: #FFFFFF; border-radius: 20rpx; margin-bottom: 12rpx; height: 124rpx; position: relative; overflow: hidden; opacity: 1; transition-property: height, margin-bottom, opacity; transition-duration: 300ms; transition-timing-function: ease-in-out; }
.task-item-hidden { height: 0; margin-bottom: 0; opacity: 0; }
.task-content-wrapper { flex-direction: row; height: 124rpx; background-color: #FFFFFF; border-radius: 20rpx; width: 686rpx; }
.task-content { flex-direction: row; align-items: flex-start; padding: 24rpx; flex: 1; position: relative; }
.task-content-animating { transition-property: transform; transition-duration: 300ms; transition-timing-function: ease-out; }
.pinned-mark { position: absolute; top: 0; left: 0; width: 20rpx; height: 20rpx; background-color: #F1795C; border-bottom-right-radius: 20rpx; }
.checkbox-click-area { position: absolute; left: 0; top: 0; bottom: 0; width: 343rpx; z-index: 10; }
.checkbox { width: 44rpx; height: 44rpx; border-radius: 12rpx; margin-top: 4rpx; margin-right: 20rpx; justify-content: center; align-items: center; border-style: solid; border-width: 4rpx; background-color: #FFFFFF; }
.checkbox-pending { border-color: #D1D5DC; }
.checkbox-completed { border-color: #F1795C; background-color: #F1795C; }
.icon-check { width: 24rpx; height: 20rpx; }
.task-details { flex: 1; }
.task-name { font-size: 28rpx; color: #101828; margin-bottom: 4rpx; }
.text-completed { color: #99A1AF; text-decoration: line-through; }
.task-meta { flex-direction: row; align-items: center; }
.icon-tiny { width: 24rpx; height: 24px; margin-right: 8rpx; }
.task-time { font-size: 24rpx; color: #6A7282; }
.listening-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center; z-index: 999; }
.listening-content { align-items: center; justify-content: center; }
.listening-icon-container { width: 160rpx; height: 160rpx; background-color: #F1795C; border-radius: 80rpx; justify-content: center; align-items: center; margin-bottom: 40rpx; position: relative; }
.ripple-ring { position: absolute; top: -20rpx; left: -20rpx; right: -20rpx; bottom: -20rpx; border-width: 8rpx; border-color: rgba(241, 121, 92, 0.4); border-radius: 100rpx; border-style: solid; }
.listening-icon { width: 64rpx; height: 64rpx; }
.listening-text { color: #FFFFFF; font-size: 32rpx; font-weight: bold; }
.tooltip-mask { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 998; }
.tooltip-box { position: fixed; width: 240rpx; background-color: #FFFFFF; border-radius: 16rpx; box-shadow: 0 4rpx 16rpx rgba(0,0,0,0.15); z-index: 999; flex-direction: column; }
.tooltip-item { height: 88rpx; justify-content: center; align-items: center; }
.tooltip-text { font-size: 28rpx; color: #101828; }
.text-red { color: #FF4D4F; }
.tooltip-separator { height: 2rpx; background-color: #F3F4F6; width: 240rpx; }
</style>