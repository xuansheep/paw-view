<template>
  <view class="container">
    <scroll-view scroll-y="true" class="scroll-container">
      <view class="page-content">
        <!-- Header -->
        <view class="header-section">
          <text class="header-title">今日待办</text>
          <view class="date-row">
            <image class="icon-small" src="/static/calendar-icon.png" mode="aspectFit"></image>
            <text class="date-text">{{ todayDateStr }}</text>
          </view>
        </view>

        <!-- Pending Tasks -->
        <view class="section-container">
          <view class="section-header">
            <view class="indicator-line bg-orange"></view>
            <text class="section-title">待完成</text>
            <view class="count-badge">
              <text class="count-text">{{ pendingTasks.length }}</text>
            </view>
          </view>

          <view class="task-list">
            <view class="task-item" :class="[task.animationClass || '']" v-for="(task, index) in pendingTasks" :key="task.id" @touchstart="onTaskTouchStart">
                <view class="task-content-wrapper" 
                      :class="[(!task.isDragging ? 'task-content-animating' : '')]"
                      @longpress="showTaskMenu($event, task)"
                      :style="{ transform: 'translateX(' + (task.offsetX || 0) + 'rpx)' }">
                    <view v-if="task.pinned" class="pinned-mark"></view>
                    <view class="task-content">
                        <view class="checkbox-click-area" @click.stop="toggleTask(task.id)"></view>
                        <view class="checkbox checkbox-pending"></view>
                        <view class="task-details">
                            <text class="task-name">{{ task.name }}</text>
                            <view class="task-meta">
                                <image class="icon-tiny" src="/static/clock-icon.png" mode="aspectFit"></image>
                                <text class="task-time">{{ task.time }}</text>
                            </view>
                        </view>
                    </view>
                </view>
            </view>
          </view>
        </view>

        <!-- Completed Tasks -->
        <view class="section-container">
          <view class="section-header">
            <view class="indicator-line bg-green"></view>
            <text class="section-title">已完成</text>
            <view class="count-badge">
              <text class="count-text">{{ completedTasks.length }}</text>
            </view>
          </view>

          <view class="task-list">
            <view class="task-item" :class="[task.animationClass || '']" v-for="(task, index) in completedTasks" :key="task.id" @touchstart="onTaskTouchStart">
                <view class="task-content-wrapper"
                      @longpress="showTaskMenu($event, task)"
                      :style="{ transform: 'translateX(' + (task.offsetX || 0) + 'rpx)' }">
                    <view v-if="task.pinned" class="pinned-mark"></view>
                    <view class="task-content">
                        <view class="checkbox-click-area" @click.stop="toggleTask(task.id)"></view>
                        <view class="checkbox checkbox-completed">
                            <image class="icon-check" src="/static/check-icon.png" mode="aspectFit"></image>
                        </view>
                        <view class="task-details">
                            <text class="task-name text-completed">{{ task.name }}</text>
                            <view class="task-meta">
                                <image class="icon-tiny" src="/static/clock-icon.png" mode="aspectFit"></image>
                                <text class="task-time">{{ task.time }}</text>
                            </view>
                        </view>
                    </view>
                </view>
            </view>
          </view>
        </view>
      </view>
    </scroll-view>

    <!-- Navigation -->
    <tab-bar
      current-page="index"
      @voice-click="showVoiceModal = true"
      @voice-longpress="onVoiceLongPress"
      @voice-touchend="onVoiceTouchEnd"
    ></tab-bar>

    <!-- Voice Modal -->
    <voice-modal :show="showVoiceModal" @close="showVoiceModal = false" @create-task="handleCreateTask"></voice-modal>

    <!-- Listening Overlay -->
    <view v-if="isListening" class="listening-overlay">
      <view class="listening-content">
        <view class="listening-icon-container">
           <image class="listening-icon" src="/static/mic-icon-white.png" mode="aspectFit"></image>
           <view class="ripple-ring"></view>
        </view>
        <text class="listening-text">{{ realTimeText || '正在听...' }}</text>
      </view>
    </view>

    <!-- Tooltip -->
    <view v-if="tooltip.visible" class="tooltip-mask" @click="hideTooltip"></view>
    <view v-if="tooltip.visible" class="tooltip-box" :style="{ top: tooltip.top + 'px', left: tooltip.left + 'px' }">
        <view class="tooltip-item" @click="togglePin">
            <text class="tooltip-text">{{ tooltip.isPinned ? '取消置顶' : '置顶' }}</text>
        </view>
        <view class="tooltip-separator"></view>
        <view class="tooltip-item" @click="deleteTask()">
            <text class="tooltip-text text-red">删除</text>
        </view>
    </view>
  </view>
</template>

<script>
import VoiceModal from '@/components/VoiceModal.nvue';
import TabBar from '@/components/TabBar.nvue';
import db from '@/utils/db.js';

// #ifdef APP-NVUE
const dom = uni.requireNativePlugin('dom');
// #endif

// Recorder and Socket configuration
const RECORDER_OPTS = {
    duration: 60000,
    sampleRate: 16000,
    numberOfChannels: 1,
    format: 'pcm',
    frameSize: 6400 // approx 0.2s for 16k 16bit mono (16000 * 2 * 0.2)
};
const WS_URL = "ws://openspeech.corgier.cn/ws/asr";

export default {
  components: {
    VoiceModal,
    TabBar
  },
  data() {
    return {
      showVoiceModal: false,
      isListening: false,
      realTimeText: '', // Display real-time ASR result
      isConnectionPending: false,
      isSocketClosing: false,
      currentSessionId: 0,
      tasks: [],
      pendingTasks: [],
      completedTasks: [],
      pixelRatio: 2,
      windowWidth: 0,
      windowHeight: 0,
      ignoreClick: false, // Flag to prevent click after longpress

      // Captured Coords for Tooltip
      lastTouchX: 0,
      lastTouchY: 0,

      // Tooltip State
      tooltip: {
        visible: false,
        top: 0,
        left: 0,
        taskId: null,
        isPinned: false
      }
    };
  },
  computed: {
    todayDateStr() {
      const now = new Date();
      const month = now.getMonth() + 1;
      const day = now.getDate();
      const weekDays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      const weekDay = weekDays[now.getDay()];
      return `${month}月${day}日 ${weekDay}`;
    }
  },
  methods: {
    async loadTasks() {
        const dbTasks = await db.getTasksByDate();
        this.tasks = dbTasks.map(t => ({
            ...t,
            animationClass: '',
            _isAnimating: false
        }));
        this.pendingTasks = this.tasks.filter(task => !task.completed);
        this.completedTasks = this.tasks.filter(task => task.completed);
    },
    async toggleTask(taskId) {
      if (this.ignoreClick) return; // Ignore if longpress just happened

      const task = this.tasks.find(t => t.id === taskId);
      if (task) {
        if (task._isAnimating) return;
        task._isAnimating = true;

        // 1. Animate Out
        task.animationClass = 'task-item-hidden';

        setTimeout(async () => {
            const oldStatus = task.completed;
            task.completed = !task.completed;

            // Refresh lists immediately
            this.pendingTasks = this.tasks.filter(t => !t.completed);
            this.completedTasks = this.tasks.filter(t => t.completed);

            // 2. Animate In (in new list)
            this.$nextTick(() => {
                setTimeout(() => {
                   task.animationClass = ''; // Reset to normal (expand)

                   setTimeout(() => {
                       task._isAnimating = false;
                   }, 300);
                }, 50);
            });

            await db.toggleTaskStatus(taskId, oldStatus);
        }, 300);
      }
    },
    async deleteTask(taskId) {
        const id = taskId || this.tooltip.taskId;
        if (!id) return;

        const index = this.tasks.findIndex(t => t.id === id);
        if (index > -1) {
            this.tasks.splice(index, 1);
            await db.deleteTask(id);
        }
        this.hideTooltip();
        this.loadTasks(); 
    },
    togglePin() {
        if (!this.tooltip.taskId) return;

        const task = this.tasks.find(t => t.id === this.tooltip.taskId);
        if (task) {
            // Optimistic Update with $set to ensure reactivity in nvue
            const oldPinned = task.pinned;
            const newPinned = !oldPinned;
            
            this.$set(task, 'pinned', newPinned);

            // Force reactivity by re-assigning the filtered lists
            // This ensures the v-for loop updates and the class binding is re-evaluated
            this.pendingTasks = this.tasks.filter(t => !t.completed);
            this.completedTasks = this.tasks.filter(t => t.completed);
            
            this.hideTooltip();

            // Perform DB update and reload in background
            db.toggleTaskPin(task.id, oldPinned).then(() => {
                this.loadTasks();
            });
        } else {
            this.hideTooltip();
        }
    },
    async handleCreateTask(taskName) {
      if (!taskName) return;
      await db.addTask(taskName);
      this.loadTasks();
    },

    // Tooltip Logic
    onTaskTouchStart(e) {
        if (e.changedTouches && e.changedTouches.length > 0) {
            const touch = e.changedTouches[0];
            this.lastTouchX = touch.clientX || touch.screenX || touch.pageX;
            this.lastTouchY = touch.clientY || touch.screenY || touch.pageY;
        }
    },
    showTaskMenu(e, task) {
        let x = this.lastTouchX;
        let y = this.lastTouchY;

        if (!x || !y) {
             if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                x = touch.clientX || touch.screenX || touch.pageX;
                y = touch.clientY || touch.screenY || touch.pageY;
             }
        }

        if (!x || !y) {
            x = this.windowWidth / 2;
            y = this.windowHeight / 2;
        }

        const tooltipWidth = 240 / this.pixelRatio;

        let targetLeft = x - tooltipWidth - 20;
        let targetTop = y - (140 / this.pixelRatio);

        if (targetLeft < 10) targetLeft = 10;
        if (targetTop < 10) targetTop = 10;
        if (targetTop > this.windowHeight - 100) targetTop = this.windowHeight - 100;

        this.tooltip = {
            visible: true,
            top: targetTop,
            left: targetLeft,
            taskId: task.id,
            isPinned: task.pinned
        };

        this.ignoreClick = true;
        setTimeout(() => {
            this.ignoreClick = false;
        }, 500);
    },
    hideTooltip() {
        this.tooltip.visible = false;
    },

    // Voice Interaction with WebSocket
    initRecorder() {
        this.recorderManager = uni.getRecorderManager();
        this.recorderManager.onFrameRecorded((res) => {
            console.log('Frame recorded, size:', res.frameBuffer.byteLength);
            if (this.socketTask && this.isSocketOpen) {
                this.socketTask.send({
                    data: res.frameBuffer,
                    fail: (e) => {
                        console.error('Socket send failed:', JSON.stringify(e));
                    }
                });
            }
        });
        this.recorderManager.onStart(() => {
            console.log('Recorder started successfully. Options:', JSON.stringify(RECORDER_OPTS));
        });
        this.recorderManager.onError((err) => {
            console.error('Recorder error:', JSON.stringify(err));
        });
        this.recorderManager.onStop((res) => {
             console.log('Recorder stopped. Temp file:', res.tempFilePath);
        });
    },

    async onVoiceLongPress() {
      // Prevent frequent triggering
      if (this.isConnectionPending || this.isSocketClosing) return;
      
      // Check Permissions first (APP-PLUS only)
      // #ifdef APP-PLUS
      const status = await this.checkPermission();
      if (status !== 1) {
          console.log('Permission not granted');
          return;
      }
      // #endif

      this.isConnectionPending = true;

      uni.vibrateShort();
      this.isListening = true;
      this.realTimeText = '';
      this.isSocketOpen = false;
      
      // Generate new Session ID
      const sessionId = Date.now();
      this.currentSessionId = sessionId;

      // Cleanup existing socket if any (Wait for it to close)
      if (this.socketTask) {
          await this.closeSocketAsync();
      }

      // Initialize Socket
      this.socketTask = uni.connectSocket({
          url: WS_URL,
          success: () => {
              console.log('Socket connecting...', sessionId);
          },
          fail: (e) => {
              console.error('Socket connect failed', JSON.stringify(e));
              if (this.currentSessionId === sessionId) {
                 this.isConnectionPending = false;
                 this.isListening = false;
              }
          }
      });

      this.socketTask.onOpen(() => {
          if (this.currentSessionId !== sessionId) return;
          this.isConnectionPending = false;
          console.log('Socket opened', sessionId);
          if (!this.isListening) {
              console.log('User released early, closing socket');
              this.closeSocketAsync();
              return;
          }
          this.isSocketOpen = true;
          
          try {
             this.recorderManager.stop(); 
          } catch(e){}
          
          setTimeout(() => {
             if (this.currentSessionId === sessionId) {
                 this.recorderManager.start(RECORDER_OPTS);
             }
          }, 100);
      });

      this.socketTask.onMessage((res) => {
          if (this.currentSessionId !== sessionId) return;
          console.log('Socket Message Received:', res.data);
          try {
              const data = JSON.parse(res.data);
              if (data.text) {
                  this.realTimeText = data.text;
                  console.log('解析文本:', data.text);
              }
              if (data.is_final) {
                  this.finalResult = data.text;
                  console.log('识别结束，最终结果:', data.text);
              }
          } catch (e) {
              console.error('JSON parse error or non-json message', e);
          }
      });

      this.socketTask.onError((err) => {
          if (this.currentSessionId !== sessionId) return;
          console.error('Socket Error Detailed:', JSON.stringify(err));
          
          this.isConnectionPending = false;
          this.isSocketOpen = false;
          try {
              this.recorderManager.stop();
          } catch(e){}
      });
      
      this.socketTask.onClose((res) => {
          if (this.currentSessionId !== sessionId) return;
          console.log('Socket closed', sessionId, 'Reason:', JSON.stringify(res));
          this.isSocketOpen = false;
      });
    },

    closeSocketAsync() {
        return new Promise((resolve) => {
            if (this.socketTask) {
                this.isSocketClosing = true;
                try {
                    this.socketTask.close();
                } catch(e) {}
                this.socketTask = null;
                // Force wait for cleanup
                setTimeout(() => {
                    this.isSocketClosing = false;
                    resolve();
                }, 300);
            } else {
                resolve();
            }
        });
    },

    // #ifdef APP-PLUS
    async checkPermission() {
        if (uni.getSystemInfoSync().platform === 'android') {
            return new Promise((resolve) => {
                plus.android.requestPermissions(
                    ['android.permission.RECORD_AUDIO'],
                    (e) => {
                        if (e.granted.length > 0) {
                            resolve(1); // Granted
                        } else {
                            resolve(0); // Denied
                        }
                    },
                    (e) => {
                        resolve(0); // Error
                    }
                );
            });
        }
        return 1; // iOS or others, assume handled by OS/Uni
    },
    // #endif

    async onVoiceTouchEnd() {
      if (!this.isListening) return;

      // Stop recording
      if (this.recorderManager) {
          this.recorderManager.stop();
      }

      // Send STOP signal
      if (this.socketTask && this.isSocketOpen) {
          this.socketTask.send({
              data: 'STOP',
              fail: () => {
                  this.closeSocketAsync();
              }
          });
          
          // Give it a moment to receive final message then close
          setTimeout(() => {
              if (this.realTimeText) {
                  this.handleCreateTask(this.realTimeText);
              }
              this.closeSocketAsync();
              this.isListening = false;
              this.realTimeText = '';
              this.isConnectionPending = false;
          }, 500); // Wait 500ms for final response
      } else {
          this.isListening = false;
          await this.closeSocketAsync();
          this.isConnectionPending = false;
      }
    }
  },
  onShow() {
      this.loadTasks();
  },
  onLoad() {
    try {
        const res = uni.getSystemInfoSync();
        this.windowWidth = res.windowWidth;
        this.windowHeight = res.windowHeight;
        this.pixelRatio = 750 / res.windowWidth;
    } catch (e) {
        this.pixelRatio = 2;
        this.windowWidth = 375;
        this.windowHeight = 800;
    }

    this.initRecorder();

    uni.$on('add-task', async (task) => {
        if (task && task.name) {
            await db.addTask(task.name);
            this.loadTasks();
        }
    });
  },
  onUnload() {
    uni.$off('add-task');
  }
};
</script>

<style>
.container {
  flex: 1;
  background-color: #FAFAFA;
  flex-direction: column;
}

.scroll-container {
  flex: 1;
}

.page-content {
  padding-left: 32rpx;
  padding-right: 32rpx;
  padding-top: 48rpx;
  padding-bottom: 200rpx;
}

.header-section { margin-bottom: 48rpx; }
.header-title { font-size: 48rpx; font-weight: bold; color: #101828; margin-bottom: 12rpx; }
.date-row { flex-direction: row; align-items: center; }
.icon-small { width: 28rpx; height: 28rpx; margin-right: 16rpx; }
.date-text { font-size: 24rpx; color: #6A7282; }

.section-container { margin-bottom: 48rpx; }
.section-header { flex-direction: row; align-items: center; margin-bottom: 20rpx; height: 40rpx; }
.indicator-line { width: 8rpx; height: 32rpx; border-radius: 4rpx; margin-right: 16rpx; }
.bg-orange { background-color: #F1795C; }
.bg-green { background-color: #6BCF7F; }
.section-title { font-size: 28rpx; font-weight: bold; color: #101828; margin-right: 24rpx; }
.count-badge { background-color: #F3F4F6; border-radius: 8rpx; padding-left: 16rpx; padding-right: 16rpx; height: 40rpx; justify-content: center; }
.count-text { font-size: 24rpx; color: #364153; }

.task-list { flex-direction: column; }
.task-item {
    background-color: #FFFFFF;
    border-radius: 20rpx;
    margin-bottom: 12rpx;
    height: 124rpx;
    position: relative;
    overflow: hidden;
    opacity: 1;
    transition-property: height, margin-bottom, opacity;
    transition-duration: 300ms;
    transition-timing-function: ease-in-out;
}
.task-item-hidden {
    height: 0;
    margin-bottom: 0;
    opacity: 0;
}
.task-content-wrapper {
    flex-direction: row;
    height: 124rpx;
    background-color: #FFFFFF;
    border-radius: 20rpx;
    width: 686rpx;
}
.task-content {
    flex-direction: row;
    align-items: flex-start;
    padding: 24rpx;
    flex: 1;
    position: relative;
}
.task-content-animating {
    transition-property: transform;
    transition-duration: 300ms;
    transition-timing-function: ease-out;
}

.pinned-mark {
    position: absolute;
    top: 0;
    left: 0;
    width: 20rpx;
    height: 20rpx;
    background-color: #F1795C;
    border-bottom-right-radius: 20rpx;
}

.delete-btn {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 140rpx;
    background-color: #FF4D4F;
    justify-content: center;
    align-items: center;
    border-top-right-radius: 20rpx;
    border-bottom-right-radius: 20rpx;
}
.delete-text {
    color: #FFFFFF;
    font-size: 28rpx;
    font-weight: bold;
}

.checkbox-click-area {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 343rpx;
    z-index: 10;
}

.checkbox {
    width: 44rpx;
    height: 44rpx;
    border-radius: 12rpx;
    margin-top: 4rpx;
    margin-right: 20rpx;
    justify-content: center;
    align-items: center;
    border-style: solid;
    border-width: 4rpx;
    background-color: #FFFFFF;
}
.checkbox-pending {
    border-color: #D1D5DC;
}
.checkbox-completed {
    border-color: #F1795C;
    background-color: #F1795C;
}
.icon-check { width: 24rpx; height: 20rpx; }
.task-details { flex: 1; }
.task-name { font-size: 28rpx; color: #101828; margin-bottom: 4rpx; }
.text-completed { color: #99A1AF; text-decoration: line-through; }
.task-meta { flex-direction: row; align-items: center; }
.icon-tiny { width: 24rpx; height: 24px; margin-right: 8rpx; }
.task-time { font-size: 24rpx; color: #6A7282; }

.listening-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.6);
  justify-content: center;
  align-items: center;
  z-index: 999;
}

.listening-content {
  align-items: center;
  justify-content: center;
}

.listening-icon-container {
  width: 160rpx;
  height: 160rpx;
  background-color: #F1795C;
  border-radius: 80rpx;
  justify-content: center;
  align-items: center;
  margin-bottom: 40rpx;
  position: relative;
}

.ripple-ring {
  position: absolute;
  top: -20rpx;
  left: -20rpx;
  right: -20rpx;
  bottom: -20rpx;
  border-width: 8rpx;
  border-color: rgba(241, 121, 92, 0.4);
  border-radius: 100rpx;
  border-style: solid;
}

.listening-icon {
  width: 64rpx;
  height: 64rpx;
}

.listening-text {
  color: #FFFFFF;
  font-size: 32rpx;
  font-weight: bold;
}

/* Tooltip Styles */
.tooltip-mask {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 998;
}
.tooltip-box {
    position: fixed;
    width: 240rpx;
    background-color: #FFFFFF;
    border-radius: 16rpx;
    box-shadow: 0 4rpx 16rpx rgba(0,0,0,0.15);
    z-index: 999;
    flex-direction: column;
}
.tooltip-item {
    height: 88rpx;
    justify-content: center;
    align-items: center;
}
.tooltip-text {
    font-size: 28rpx;
    color: #101828;
}
.text-red {
    color: #FF4D4F;
}
.tooltip-separator {
    height: 2rpx;
    background-color: #F3F4F6;
    width: 240rpx;
}
</style>